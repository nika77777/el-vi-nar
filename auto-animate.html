<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Эль Ви-Нар — автоматическое прорисовывание</title>

  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; background: #000; }

    #starCanvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .glyphWrap {
      width: min(92vw, 2in);
      max-width: 2in;
      padding: 28px;
      overflow: visible;
    }

    svg { width: 100%; height: auto; display: block; overflow: visible; }

    /* Плавное появление “из бездны” */
    #plasmaGroup { opacity: 0; }

    /* Звёзды глифа */
    #stars .star {
      opacity: 0.05;
      transition: opacity 900ms ease, filter 900ms ease;
      filter: none;
    }
    #stars .star.on {
      opacity: 1;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.75));
    }

    /* Энергоимпульс */
    #impulse {
      opacity: 0.03;
      transition: opacity 1200ms ease, filter 1200ms ease, transform 1200ms ease;
      transform-box: fill-box;
      transform-origin: center;
      filter: drop-shadow(0 0 8px rgba(255,255,220,0.18));
    }
    #impulse.on {
      opacity: 1;
      transform: scale(1.18);
      filter:
        drop-shadow(0 0 22px rgba(255,255,230,0.95))
        drop-shadow(0 0 36px rgba(140,220,255,0.35));
    }
  </style>
</head>

<body>
  <canvas id="starCanvas"></canvas>

  <div class="overlay">
    <div class="glyphWrap">
      <svg id="glyphSvg"
           viewBox="0 0 17.471024 31.41024"
           xmlns="http://www.w3.org/2000/svg">

        <defs>
          <filter id="glowSoft" x="-60%" y="-60%" width="220%" height="220%">
            <feGaussianBlur stdDeviation="0.22" result="b"/>
            <feMerge>
              <feMergeNode in="b"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <filter id="glowOuter" x="-90%" y="-90%" width="280%" height="280%">
            <feGaussianBlur stdDeviation="0.36" result="b"/>
            <feColorMatrix in="b" type="matrix"
              values="
                1 0 0 0 0
                0 1 0 0 0
                0 1 1 0 0
                0 0 0 0.85 0" result="t"/>
            <feMerge>
              <feMergeNode in="t"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <linearGradient id="plasmaGrad" x1="0" y1="0" x2="1" y2="0">
            <stop offset="0%"   stop-color="#ffffff" stop-opacity="0.92"/>
            <stop offset="45%"  stop-color="#f4fdff" stop-opacity="1"/>
            <stop offset="55%"  stop-color="#ffffff" stop-opacity="0.96"/>
            <stop offset="100%" stop-color="#ffffff" stop-opacity="0.90"/>
          </linearGradient>
        </defs>

        <!-- Ваш слой -->
        <g id="layer1" transform="translate(-161.76484,-11.295264)">

          <!-- Звёзды (как в вашем SVG, + class="star") -->
          <g id="stars" pointer-events="none">
            <path id="star6" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,292.43213,39.873066)" />
            <path id="star3" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,288.85562,29.186314)" />
            <path id="star4" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,276.16664,39.873066)" />
            <path id="star2" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,279.74315,29.186314)" />
            <path id="star1" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,284.29938,21.326142)" />
            <path id="star5" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.141834"
              d="m 113.98988,239.23457 -1.00826,-0.35527 0.0822,1.06585 -0.46173,-0.96416 -0.69555,0.81181 0.35527,-1.00826 -1.06585,0.0822 0.96416,-0.46173 -0.8118,-0.69555 1.00826,0.35527 -0.0822,-1.06585 0.46174,0.96416 0.69554,-0.81181 -0.35527,1.00826 1.06586,-0.0822 -0.96416,0.46173 z"
              transform="matrix(0.20221877,0.75469068,0.75469068,-0.20221877,-32.256065,-9.1313715)" />
          </g>

          <!-- Энергоимпульс в точке соединения -->
          <g id="impulse" transform="translate(170.50035 27.675419)">
            <circle r="0.92" fill="#fff7c2" />
            <circle r="0.58" fill="#ffffff" opacity="0.95" />
          </g>

          <!-- Группа, в которой лежат базовые пути (для длины), и плазма-слои (мы вставим JS-ом) -->
          <g id="plasmaGroup">
            <path id="seg1" d="m 170.50035,11.955075 -4.55624,7.860171" fill="none"/>
            <path id="seg2" d="m 165.94411,19.815246 9.11247,-4e-6" fill="none"/>
            <path id="seg3" d="m 175.05658,19.815242 -4.55623,-7.860167" fill="none"/>
            <path id="seg4" d="m 165.94411,19.815248 4.55624,7.860171" fill="none"/>
            <path id="seg5" d="m 170.50035,27.675419 4.55623,-7.860167" fill="none"/>
            <path id="seg6" d="m 162.3676,30.830773 v -3.155354 h 16.26549 v 3.155354" fill="none"/>
            <path id="seg7" d="m 170.50034,27.675419 c 0,0 -0.97185,1.236575 -0.91015,1.958613 0.13716,1.60544 2.75374,2.128038 2.73044,3.917219 -0.0116,0.894587 -0.97083,1.423155 -1.90259,1.953447 -0.93175,0.530292 -1.89099,1.05886 -1.90259,1.953452 -0.0233,1.78918 2.59328,2.311779 2.73045,3.917218 0.0308,0.361018 -0.19669,0.850671 -0.43195,1.250065" fill="none"/>
          </g>

        </g>
      </svg>
    </div>
  </div>

  <script>
  (() => {
    /* ---------- ФОН: звёздное небо ---------- */
    const canvas = document.getElementById('starCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    const DPR = () => Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let W = 0, H = 0, dpr = 1;
    const stars = [];
    const STAR_COUNT = 260;

    function rand(min, max) { return min + Math.random() * (max - min); }

    function resizeCanvas() {
      dpr = DPR();
      W = Math.floor(window.innerWidth * dpr);
      H = Math.floor(window.innerHeight * dpr);
      canvas.width = W;
      canvas.height = H;
    }

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        const z = Math.pow(Math.random(), 1.9);
        stars.push({
          x: Math.random(),
          y: Math.random(),
          r: rand(0.22, 1.35) * (0.35 + (1 - z)),
          a: rand(0.18, 1.0),
          tw: rand(0.55, 1.9),
          ph: rand(0, Math.PI * 2),
          cool: Math.random() > 0.55
        });
      }
    }

    function drawStars(t) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const time = t * 0.001;
      for (const s of stars) {
        const x = s.x * W;
        const y = s.y * H;
        const tw = 0.62 + 0.38 * Math.sin(time * s.tw + s.ph);
        const a = s.a * tw;

        const col = s.cool ? `rgba(215,238,255,${a})` : `rgba(255,238,220,${a})`;

        ctx.beginPath();
        ctx.fillStyle = col;
        ctx.arc(x, y, s.r * dpr, 0, Math.PI * 2);
        ctx.fill();
      }

      const g = ctx.createRadialGradient(W*0.56, H*0.42, 0, W*0.56, H*0.42, Math.min(W,H)*0.68);
      g.addColorStop(0, 'rgba(70,110,170,0.05)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);
    }

    resizeCanvas();
    initStars();
    window.addEventListener('resize', () => { resizeCanvas(); initStars(); });

    /* ---------- SVG: супер-плавная прорисовка ---------- */
    const svg = document.getElementById('glyphSvg');
    const plasmaGroup = svg.querySelector('#plasmaGroup');
    const impulse = svg.querySelector('#impulse');
    const starEls = Array.from(svg.querySelectorAll('#stars .star'));

    function resetStars() {
      for (const s of starEls) s.classList.remove('on');
      if (impulse) impulse.classList.remove('on');
    }

    // ВАЖНО: убрали порог — всегда выбираем ближайшую звезду
    function starCenter(el) {
      const b = el.getBBox();
      return { x: b.x + b.width/2, y: b.y + b.height/2 };
    }
    function nearestStarToPoint(pt) {
      let best = null;
      let bestD2 = Infinity;
      for (const s of starEls) {
        const c = starCenter(s);
        const dx = c.x - pt.x;
        const dy = c.y - pt.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
      return best;
    }
    function starOn(el) { if (el) el.classList.add('on'); }

    const order = ['seg1','seg2','seg3','seg4','seg5','seg6','seg7'];

    // Easing: мягкий smoothstep
    function smoothstep(t) { return t * t * (3 - 2 * t); }

    // Общий fade-in “из бездны”
    const FADE_IN_MS = 3200;
    const PRE_DELAY_MS = 450;

    // Главная настройка скорости:
    // Чем больше значение, тем медленнее, и длинные сегменты будут длиться пропорционально дольше.
    const MS_PER_UNIT = 200;

    // Минимальная длительность сегмента (чтобы короткие тоже не щёлкали)
    const MIN_SEG_MS = 1400;

    function makePlasmaLayers(basePath) {
      const d = basePath.getAttribute('d');
      const baseSW = 0.365878;

      // Фикс “второй сегмент тоньше”: увеличили ядро чуть-чуть,
      // и добавили общий “унифицирующий” слой (inner)
      const outerW = baseSW * 1.22;
      const innerW = baseSW * 1.08;
      const coreW  = baseSW * 0.92;

      const mk = (strokeW, filterId, opacity) => {
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        p.setAttribute('d', d);
        p.setAttribute('fill', 'none');
        p.setAttribute('stroke', 'url(#plasmaGrad)');
        p.setAttribute('stroke-linecap', 'round');
        p.setAttribute('stroke-linejoin', 'round');
        p.setAttribute('stroke-width', String(strokeW));
        p.setAttribute('opacity', String(opacity));
        if (filterId) p.setAttribute('filter', `url(#${filterId})`);
        return p;
      };

      const outer = mk(outerW, 'glowOuter', 0.22);
      const inner = mk(innerW, 'glowSoft',  0.52);
      const core  = mk(coreW,  null,        0.94);

      return [outer, inner, core];
    }

    // Готовим сегменты и строим таймлайн строго по длине
    const segments = [];
    for (const id of order) {
      const base = svg.querySelector('#' + CSS.escape(id));
      if (!base) continue;

      const total = base.getTotalLength();
      const layers = makePlasmaLayers(base);

      // Вставляем слои сразу ПОСЛЕ base (в правильном порядке)
      for (let i = layers.length - 1; i >= 0; i--) {
        base.parentNode.insertBefore(layers[i], base.nextSibling);
      }

      // базовый путь оставляем невидимым
      base.style.stroke = 'none';
      base.style.fill = 'none';

      for (const p of layers) {
        p.style.strokeDasharray = String(total);
        p.style.strokeDashoffset = String(total);
      }

      segments.push({ id, base, total, layers, starStartDone: false, starEndDone: false });
    }

    // Таймлайн: каждый сегмент = длина * MS_PER_UNIT (пропорционально)
    let tCursor = PRE_DELAY_MS;
    for (const s of segments) {
      const dur = Math.max(MIN_SEG_MS, s.total * MS_PER_UNIT);
      s.t0 = tCursor;
      s.t1 = tCursor + dur;
      tCursor = s.t1; // без пауз
    }
    const TOTAL_MS = tCursor + 1200;

    resetStars();

    // Подсветим первую звезду у старта (чуть-чуть раньше, когда начнёт проявляться)
    const firstStartPt = segments[0]?.base.getPointAtLength(0);
    const firstStar = firstStartPt ? nearestStarToPoint(firstStartPt) : null;

    function animate(ts0) {
      function frame(ts) {
        drawStars(ts);

        const elapsed = ts - ts0;

        // Fade-in всей плазмы
        const fadeT = Math.max(0, Math.min(1, elapsed / FADE_IN_MS));
        plasmaGroup.style.opacity = String(0.02 + 0.98 * smoothstep(fadeT));

        // как только реально стартуем — зажигаем первую звезду
        if (elapsed > PRE_DELAY_MS + 120 && firstStar) starOn(firstStar);

        for (const s of segments) {
          let t = 0;
          if (elapsed <= s.t0) t = 0;
          else if (elapsed >= s.t1) t = 1;
          else t = (elapsed - s.t0) / (s.t1 - s.t0);

          const eased = smoothstep(t);
          const drawLen = s.total * eased;
          const offset = s.total - drawLen;

          for (const p of s.layers) {
            p.style.strokeDashoffset = String(offset);
          }

          // Включаем звезду начала, когда сегмент реально “пошёл”
          if (t > 0.10 && !s.starStartDone) {
            const startPt = s.base.getPointAtLength(0);
            starOn(nearestStarToPoint(startPt));
            s.starStartDone = true;
          }

          // Включаем звезду конца, когда почти дошли
          if (t > 0.90 && !s.starEndDone) {
            const endPt = s.base.getPointAtLength(s.total);
            starOn(nearestStarToPoint(endPt));
            s.starEndDone = true;
          }
        }

        // Финал: импульс усиливается только под самый конец
        if (impulse) {
          const endPhaseStart = TOTAL_MS - 1200;
          if (elapsed > endPhaseStart) impulse.classList.add('on');
        }

        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }

    requestAnimationFrame(animate);
  })();
  </script>
</body>
</html>
