<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Эль Ви-Нар — автоматическое прорисовывание</title>

  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
    }

    /* Фон: звёздное небо */
    #starCanvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    /* Слой глифа */
    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    /* Глиф не больше 2 дюймов, но с запасом под свечение (без обрезки) */
    .glyphWrap {
      width: min(92vw, 2in);
      max-width: 2in;
      padding: 28px;
      overflow: visible;
    }

    svg {
      width: 100%;
      height: auto;
      display: block;
      overflow: visible;
    }

    /* Общее “появление из бездны” */
    #plasmaGroup {
      opacity: 0;
      transition: opacity 0.0s;
    }

    /* Звёзды глифа: по умолчанию почти невидимы, затем плавно “включаются” */
    #stars .star {
      opacity: 0.06;
      transition: opacity 900ms ease, filter 900ms ease;
      filter: none;
    }
    #stars .star.on {
      opacity: 1;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.75));
    }

    /* Энергоимпульс: тихий в начале, яркий в самом конце */
    #impulse {
      opacity: 0.03;
      transition: opacity 1200ms ease, filter 1200ms ease, transform 1200ms ease;
      transform-box: fill-box;
      transform-origin: center;
      filter: drop-shadow(0 0 8px rgba(255,255,220,0.18));
    }
    #impulse.on {
      opacity: 1;
      transform: scale(1.18);
      filter:
        drop-shadow(0 0 22px rgba(255,255,230,0.95))
        drop-shadow(0 0 36px rgba(140,220,255,0.35));
    }
  </style>
</head>

<body>
  <canvas id="starCanvas"></canvas>

  <div class="overlay">
    <div class="glyphWrap">
      <svg id="glyphSvg"
           viewBox="0 0 17.471024 31.41024"
           xmlns="http://www.w3.org/2000/svg">

        <defs>
          <!-- Очень мягкое, тонкое свечение -->
          <filter id="glowSoft" x="-60%" y="-60%" width="220%" height="220%">
            <feGaussianBlur stdDeviation="0.22" result="b"/>
            <feMerge>
              <feMergeNode in="b"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <filter id="glowOuter" x="-90%" y="-90%" width="280%" height="280%">
            <feGaussianBlur stdDeviation="0.38" result="b"/>
            <feColorMatrix in="b" type="matrix"
              values="
                1 0 0 0 0
                0 1 0 0 0
                0 1 1 0 0
                0 0 0 0.85 0" result="t"/>
            <feMerge>
              <feMergeNode in="t"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <!-- Очень “чистая” белая плазма с лёгким ледяным отблеском -->
          <linearGradient id="plasmaGrad" x1="0" y1="0" x2="1" y2="0">
            <stop offset="0%"   stop-color="#ffffff" stop-opacity="0.92"/>
            <stop offset="45%"  stop-color="#f4fdff" stop-opacity="1"/>
            <stop offset="55%"  stop-color="#ffffff" stop-opacity="0.96"/>
            <stop offset="100%" stop-color="#ffffff" stop-opacity="0.90"/>
          </linearGradient>
        </defs>

        <!-- ВАШ КОНТЕНТ: берём вашу геометрию, но без xml и без stroke:none на слое -->
        <g id="layer1" transform="translate(-161.76484,-11.295264)">

          <!-- Звёзды: остаются, но станут “реалистичнее” за счёт opacity+glow -->
          <g id="stars" pointer-events="none">
            <path id="star6" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,292.43213,39.873066)" />
            <path id="star3" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,288.85562,29.186314)" />
            <path id="star4" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,276.16664,39.873066)" />
            <path id="star2" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,279.74315,29.186314)" />
            <path id="star1" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.256063"
              d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z"
              transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,284.29938,21.326142)" />
            <path id="star5" class="star" fill="#ffffff" stroke="#ffffff" stroke-width="0.141834"
              d="m 113.98988,239.23457 -1.00826,-0.35527 0.0822,1.06585 -0.46173,-0.96416 -0.69555,0.81181 0.35527,-1.00826 -1.06585,0.0822 0.96416,-0.46173 -0.8118,-0.69555 1.00826,0.35527 -0.0822,-1.06585 0.46174,0.96416 0.69554,-0.81181 -0.35527,1.00826 1.06586,-0.0822 -0.96416,0.46173 z"
              transform="matrix(0.20221877,0.75469068,0.75469068,-0.20221877,-32.256065,-9.1313715)" />
          </g>

          <!-- Энергоимпульс в точке соединения (170.50035, 27.675419) -->
          <g id="impulse" transform="translate(170.50035 27.675419)">
            <circle r="0.92" fill="#fff7c2" />
            <circle r="0.58" fill="#ffffff" opacity="0.95" />
          </g>

          <!-- Группа плазмы (будем плавно проявлять opacity) -->
          <g id="plasmaGroup">
            <!-- Исходные пути (без видимого stroke): используем только для длины/точек -->
            <path id="seg1" d="m 170.50035,11.955075 -4.55624,7.860171" fill="none"/>
            <path id="seg2" d="m 165.94411,19.815246 9.11247,-4e-6" fill="none"/>
            <path id="seg3" d="m 175.05658,19.815242 -4.55623,-7.860167" fill="none"/>
            <path id="seg4" d="m 165.94411,19.815248 4.55624,7.860171" fill="none"/>
            <path id="seg5" d="m 170.50035,27.675419 4.55623,-7.860167" fill="none"/>
            <path id="seg6" d="m 162.3676,30.830773 v -3.155354 h 16.26549 v 3.155354" fill="none"/>
            <path id="seg7" d="m 170.50034,27.675419 c 0,0 -0.97185,1.236575 -0.91015,1.958613 0.13716,1.60544 2.75374,2.128038 2.73044,3.917219 -0.0116,0.894587 -0.97083,1.423155 -1.90259,1.953447 -0.93175,0.530292 -1.89099,1.05886 -1.90259,1.953452 -0.0233,1.78918 2.59328,2.311779 2.73045,3.917218 0.0308,0.361018 -0.19669,0.850671 -0.43195,1.250065" fill="none"/>
          </g>

        </g>
      </svg>
    </div>
  </div>

  <script>
  (() => {
    /* ---------- ФОН: “настоящее” звёздное небо ---------- */
    const canvas = document.getElementById('starCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    const DPR = () => Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let W = 0, H = 0, dpr = 1;
    const stars = [];
    const STAR_COUNT = 260;

    function rand(min, max) { return min + Math.random() * (max - min); }

    function resizeCanvas() {
      dpr = DPR();
      W = Math.floor(window.innerWidth * dpr);
      H = Math.floor(window.innerHeight * dpr);
      canvas.width = W;
      canvas.height = H;
    }

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        const z = Math.pow(Math.random(), 1.9);
        stars.push({
          x: Math.random(),
          y: Math.random(),
          r: rand(0.22, 1.35) * (0.35 + (1 - z)),
          a: rand(0.18, 1.0),
          tw: rand(0.55, 1.9),
          ph: rand(0, Math.PI * 2),
          cool: Math.random() > 0.55
        });
      }
    }

    function drawStars(t) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const time = t * 0.001;
      for (const s of stars) {
        const x = s.x * W;
        const y = s.y * H;
        const tw = 0.62 + 0.38 * Math.sin(time * s.tw + s.ph);
        const a = s.a * tw;

        const col = s.cool ? `rgba(215,238,255,${a})` : `rgba(255,238,220,${a})`;

        ctx.beginPath();
        ctx.fillStyle = col;
        ctx.arc(x, y, s.r * dpr, 0, Math.PI * 2);
        ctx.fill();
      }

      // очень мягкая дымка
      const g = ctx.createRadialGradient(W*0.56, H*0.42, 0, W*0.56, H*0.42, Math.min(W,H)*0.68);
      g.addColorStop(0, 'rgba(70,110,170,0.05)');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);
    }

    resizeCanvas();
    initStars();
    window.addEventListener('resize', () => { resizeCanvas(); initStars(); });

    /* ---------- SVG АНИМАЦИЯ: супер-плавная, тонкая плазма, без контуров ---------- */
    const svg = document.getElementById('glyphSvg');
    const plasmaGroup = svg.querySelector('#plasmaGroup');
    const impulse = svg.querySelector('#impulse');
    const starEls = Array.from(svg.querySelectorAll('#stars .star'));

    function resetStars() {
      for (const s of starEls) s.classList.remove('on');
      if (impulse) impulse.classList.remove('on');
    }

    function starCenter(el) {
      const b = el.getBBox();
      return { x: b.x + b.width/2, y: b.y + b.height/2 };
    }

    function nearestStarToPoint(pt) {
      let best = null;
      let bestD2 = Infinity;
      for (const s of starEls) {
        const c = starCenter(s);
        const dx = c.x - pt.x;
        const dy = c.y - pt.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
      const TH = 6.0;
      return bestD2 <= TH*TH ? best : null;
    }

    function starOn(el) { if (el) el.classList.add('on'); }

    // Порядок (как вы задавали)
    const order = ['seg1','seg2','seg3','seg4','seg5','seg6','seg7'];

    // Создаём плазму-пути поверх исходных seg*
    function makePlasmaLayers(basePath) {
      const d = basePath.getAttribute('d');
      const baseSW = 0.365878;

      // ТОНКО: внешний слой слегка шире, но не “труба”
      const outerW = baseSW * 1.45;
      const innerW = baseSW * 1.15;
      const coreW  = baseSW * 0.88;

      const mk = (strokeW, filterId, opacity) => {
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        p.setAttribute('d', d);
        p.setAttribute('fill', 'none');
        p.setAttribute('stroke', 'url(#plasmaGrad)');
        p.setAttribute('stroke-linecap', 'round');
        p.setAttribute('stroke-linejoin', 'round');
        p.setAttribute('stroke-width', String(strokeW));
        p.setAttribute('opacity', String(opacity));
        if (filterId) p.setAttribute('filter', `url(#${filterId})`);
        return p;
      };

      const outer = mk(outerW, 'glowOuter', 0.28);
      const inner = mk(innerW, 'glowSoft',  0.55);
      const core  = mk(coreW,  null,        0.92);

      return [outer, inner, core];
    }

    // Подготовка сегментов: строим timeline без пауз и без рывков
    const segments = [];
    for (const id of order) {
      const base = svg.querySelector('#' + CSS.escape(id));
      if (!base) continue;

      const total = base.getTotalLength();
      const layers = makePlasmaLayers(base);

      // Вставляем плазму после base (но base остаётся невидимым для расчётов)
      const parent = base.parentNode;
      for (const p of layers) parent.insertBefore(p, base.nextSibling);

      base.style.stroke = 'none';
      base.style.fill = 'none';

      for (const p of layers) {
        p.style.strokeDasharray = String(total);
        p.style.strokeDashoffset = String(total);
      }

      segments.push({ id, base, total, layers });
    }

    // easing: очень плавное ускорение/замедление
    function smoothstep(t) {
      // t: 0..1
      return t * t * (3 - 2 * t);
    }

    // Общий fade-in “из бездны”
    const FADE_IN_MS = 2600;

    // Длительность прорисовки каждого сегмента (мс): подбирается по длине, чтобы не было скачков
    // Чем больше множитель, тем медленнее.
    const MS_PER_UNIT = 120; // тонко и плавно; можно 90 быстрее, 150 медленнее

    // Стартовая пауза “из тьмы” (очень короткая, почти незаметная)
    const PRE_DELAY_MS = 350;

    // Таймлайн сегментов: старт/конец по времени
    let tCursor = PRE_DELAY_MS;
    for (const s of segments) {
      const dur = Math.max(900, s.total * MS_PER_UNIT);
      s.t0 = tCursor;
      s.t1 = tCursor + dur;
      tCursor = s.t1; // без пауз
    }
    const TOTAL_MS = tCursor + 900; // небольшой хвост для финального усиления импульса

    resetStars();

    // На старте подсветим “первую” звезду рядом с началом первого сегмента (почти незаметно, но красиво)
    if (segments[0]) {
      const p0 = segments[0].base.getPointAtLength(0);
      starOn(nearestStarToPoint(p0));
    }

    function animate(ts0) {
      function frame(ts) {
        drawStars(ts);

        const elapsed = ts - ts0;

        // Общий fade-in
        const fadeT = Math.max(0, Math.min(1, elapsed / FADE_IN_MS));
        if (plasmaGroup) plasmaGroup.style.opacity = String(0.02 + 0.98 * smoothstep(fadeT));

        // Прорисовка сегментов строго по таймлайну (без пауз, без рывков)
        for (const s of segments) {
          let t = 0;
          if (elapsed <= s.t0) {
            t = 0;
          } else if (elapsed >= s.t1) {
            t = 1;
          } else {
            t = (elapsed - s.t0) / (s.t1 - s.t0);
          }

          const eased = smoothstep(t);
          const drawLen = s.total * eased;
          const offset = s.total - drawLen;

          for (const p of s.layers) {
            p.style.strokeDashoffset = String(offset);
          }

          // “загорание” звёзд: когда сегмент почти дошёл до конца
          if (t > 0.92 && !s.starEndDone) {
            const endPt = s.base.getPointAtLength(s.total);
            starOn(nearestStarToPoint(endPt));
            s.starEndDone = true;
          }

          // “загорание” звезды начала (когда сегмент реально начал проявляться)
          if (t > 0.08 && !s.starStartDone) {
            const startPt = s.base.getPointAtLength(0);
            starOn(nearestStarToPoint(startPt));
            s.starStartDone = true;
          }
        }

        // Финальное усиление энергоимпульса — только под самый конец (без ранних включений)
        if (impulse) {
          const endPhaseStart = TOTAL_MS - 900;
          if (elapsed > endPhaseStart) {
            impulse.classList.add('on');
          }
        }

        requestAnimationFrame(frame);
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(animate);
  })();
  </script>
</body>
</html>
