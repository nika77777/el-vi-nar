<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Эль Ви-Нар — тренажёр порядка рисования</title>

  <style>
    :root { color-scheme: light; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; line-height: 1.35; }
    .wrap { max-width: 860px; margin: 0 auto; padding: 16px; }
    h1 { font-size: 20px; margin: 0 0 10px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 10px 0 14px; }
    .pill { display: inline-block; border: 1px solid #ddd; border-radius: 999px; padding: 6px 10px; font-size: 13px; opacity: 0.9; }
    .stepTitle { font-size: 14px; font-weight: 700; }
    button { appearance: none; border: 1px solid #ccc; background: #fff; padding: 10px 12px; border-radius: 10px; font-weight: 600; cursor: pointer; }
    button:active { transform: translateY(1px); }

    /* Важно: чтобы ничего не обрезало движок */
    .stage {
      border: 1px solid #e3e3e3;
      border-radius: 14px;
      padding: 22px;                 /* запас, чтобы движок не резало */
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      overflow: visible;             /* ключевой фикс обрезки */
    }

    /* Максимальная ширина глифа ~2 дюйма, на телефоне адаптивно */
    .glyphBox {
      width: min(92vw, 2in);
      max-width: 2in;
      margin: 0 auto;
      padding: 12px;                 /* ещё чуть запаса внутри */
      overflow: visible;             /* ключевой фикс обрезки */
    }
    .glyphBox svg { width: 100%; height: auto; display: block; overflow: visible; }

    .muted { opacity: 0.75; font-size: 13px; }

    /* Звёзды по умолчанию бледные, включённые — яркие */
    #stars .star {
      opacity: 0.18;
      transition: opacity 180ms linear;
    }
    #stars .star.on { opacity: 1; }

    /* Движок: пульсирует, чтобы было понятно, что тянуть */
    #handle {
      transform-box: fill-box;
      transform-origin: center;
      animation: pulse 1.1s infinite;
    }
    .dragging #handle { animation: none; }

    /* На переключении шага делаем короткую “телепортацию” */
    .teleport #handle {
      animation: none;
      opacity: 0;
      transition: opacity 120ms linear;
    }

    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.35; transform: scale(1.22); }
      100% { opacity: 1; transform: scale(1); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Эль Ви-Нар — тренажёр порядка рисования</h1>

    <div class="row">
      <span class="pill" id="stepPill">Шаг 1 из 7</span>
      <span class="pill stepTitle" id="stepText">Зеркало Бытия → Зеркало Души</span>
    </div>

    <div class="row">
      <button id="btnReset" type="button">Сброс</button>
      <span class="muted">Начинайте с движка (кружка). Ведите его близко к линии. Движение назад запрещено.</span>
    </div>

    <div class="stage" id="stage">
      <div class="glyphBox">
        <!-- Ваш SVG: без xml-заголовка; на слое убран stroke:none -->
        <svg
          width="17.471024mm"
          height="31.41024mm"
          viewBox="0 0 17.471024 31.41024"
          version="1.1"
          id="svg5"
          xmlns="http://www.w3.org/2000/svg"
          xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
          xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd">

          <defs id="defs2" />

          <g
            inkscape:label="all"
            inkscape:groupmode="layer"
            id="layer1"
            style="display:inline"
            transform="translate(-161.76484,-11.295264)">

            <path
              style="fill:none;stroke:#000000;stroke-width:0.365878;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
              d="m 162.3676,30.830773 v -3.155354 h 16.26549 v 3.155354"
              id="seg6" />

            <path
              style="fill:none;stroke:#000000;stroke-width:0.365878;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
              d="m 170.50035,11.955075 -4.55624,7.860171"
              id="seg1" />

            <path
              style="fill:none;stroke:#000000;stroke-width:0.365878;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
              d="m 165.94411,19.815246 9.11247,-4e-6"
              id="seg2" />

            <path
              style="fill:none;stroke:#000000;stroke-width:0.365878;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
              d="m 175.05658,19.815242 -4.55623,-7.860167"
              id="seg3" />

            <path
              style="fill:none;stroke:#000000;stroke-width:0.365878;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
              d="m 165.94411,19.815248 4.55624,7.860171"
              id="seg4" />

            <path
              style="fill:none;stroke:#000000;stroke-width:0.365878;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
              d="m 170.50035,27.675419 4.55623,-7.860167"
              id="seg5" />

            <path
              id="seg7"
              style="fill:none;stroke:#000000;stroke-width:0.365878;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
              d="m 170.50034,27.675419 c 0,0 -0.97185,1.236575 -0.91015,1.958613 0.13716,1.60544 2.75374,2.128038 2.73044,3.917219 -0.0116,0.894587 -0.97083,1.423155 -1.90259,1.953447 -0.93175,0.530292 -1.89099,1.05886 -1.90259,1.953452 -0.0233,1.78918 2.59328,2.311779 2.73045,3.917218 0.0308,0.361018 -0.19669,0.850671 -0.43195,1.250065" />

            <!-- Звёзды. Важно: не перехватывают касания -->
            <g id="stars" pointer-events="none">
              <!-- ваши звёзды: добавлен class="star" -->
              <path id="star6" class="star" style="fill:#000000;stroke:#000000;stroke-width:0.256063" d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z" transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,292.43213,39.873066)" />
              <path id="star3" class="star" style="fill:#000000;stroke:#000000;stroke-width:0.256063" d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z" transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,288.85562,29.186314)" />
              <path id="star4" class="star" style="fill:#000000;stroke:#000000;stroke-width:0.256063" d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z" transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,276.16664,39.873066)" />
              <path id="star2" class="star" style="fill:#000000;stroke:#000000;stroke-width:0.256063" d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z" transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,279.74315,29.186314)" />
              <path id="star1" class="star" style="fill:#000000;stroke:#000000;stroke-width:0.256063" d="m 113.98988,239.23457 -1.0641,-0.31796 -0.25668,1.08051 -0.25669,-1.08051 -1.06409,0.31796 0.80741,-0.76255 -0.80741,-0.76256 1.06409,0.31796 0.25669,-1.08051 0.25668,1.08051 1.0641,-0.31796 -0.80741,0.76256 z" transform="matrix(-0.21646536,0.37465133,-0.37492902,-0.21630505,284.29938,21.326142)" />
              <path id="star5" class="star" style="fill:#000000;stroke:#000000;stroke-width:0.141834" d="m 113.98988,239.23457 -1.00826,-0.35527 0.0822,1.06585 -0.46173,-0.96416 -0.69555,0.81181 0.35527,-1.00826 -1.06585,0.0822 0.96416,-0.46173 -0.8118,-0.69555 1.00826,0.35527 -0.0822,-1.06585 0.46174,0.96416 0.69554,-0.81181 -0.35527,1.00826 1.06586,-0.0822 -0.96416,0.46173 z" transform="matrix(0.20221877,0.75469068,0.75469068,-0.20221877,-32.256065,-9.1313715)" />
            </g>

            <!-- Движок: увеличенный. Важно: pointer-events включены -->
            <circle
              id="handle"
              cx="170.50035"
              cy="11.955069"
              r="1.1"
              style="fill:#ffffff;stroke:#000000;stroke-width:0.35"
              pointer-events="all" />

          </g>
        </svg>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const stage = document.getElementById('stage');
    const svg = stage.querySelector('svg');
    const handle = stage.querySelector('#handle');

    const btnReset = document.getElementById('btnReset');
    const stepPill = document.getElementById('stepPill');
    const stepText = document.getElementById('stepText');

    const steps = [
      { id: 'seg1', title: 'Зеркало Бытия → Зеркало Души' },
      { id: 'seg2', title: 'Зеркало Души → Зеркало Сознания' },
      { id: 'seg3', title: 'Зеркало Сознания → Зеркало Бытия' },
      { id: 'seg4', title: 'Зеркало Души → Энергоимпульс' },
      { id: 'seg5', title: 'Энергоимпульс → Зеркало Сознания' },
      { id: 'seg6', title: 'Прошлое ↑ → через энергоимпульс → ↓ Будущее (одним штрихом)' },
      { id: 'seg7', title: 'Энергоимпульс → вниз по волне Энергии заземления' },
    ];

    const paths = steps.map(s => stage.querySelector('#' + CSS.escape(s.id)));

    if (!svg || !handle || paths.some(p => !p)) {
      console.error('Не найдены svg/handle/seg-пути. Проверьте id="handle" и id="seg1..seg7".');
      return;
    }

    // Все звёзды — бледные. Дальше будем “включать” по шагам автоматически.
    const stars = Array.from(stage.querySelectorAll('#stars .star'));
    function starsReset() { stars.forEach(s => s.classList.remove('on')); }
    function starOn(el) { if (el) el.classList.add('on'); }

    // Центр звезды по bbox
    function starCenter(starEl) {
      const b = starEl.getBBox();
      return { x: b.x + b.width / 2, y: b.y + b.height / 2 };
    }

    // Находим ближайшую звезду к точке (если близко)
    function nearestStarToPoint(pt) {
      let best = null;
      let bestD2 = Infinity;
      for (const s of stars) {
        const c = starCenter(s);
        const dx = c.x - pt.x;
        const dy = c.y - pt.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) { bestD2 = d2; best = s; }
      }
      // порог “достаточно близко” (в SVG-единицах; под ваш масштаб этого хватает)
      // можно ужесточить/ослабить при необходимости
      const TH = 6.0;
      return bestD2 <= TH*TH ? best : null;
    }

    function getStrokeWidth(path) {
      const swAttr = path.getAttribute('stroke-width');
      if (swAttr) {
        const v = parseFloat(swAttr);
        if (Number.isFinite(v) && v > 0) return v;
      }
      const style = path.getAttribute('style') || '';
      const m = style.match(/stroke-width:\s*([0-9.]+)/);
      if (m) {
        const v = parseFloat(m[1]);
        if (Number.isFinite(v) && v > 0) return v;
      }
      return 0.35;
    }

    const segState = paths.map((path) => {
      const total = path.getTotalLength();
      path.style.strokeDasharray = String(total);
      path.style.strokeDashoffset = String(total);
      path.style.fill = 'none';
      return { total, drawn: 0, strokeW: getStrokeWidth(path) };
    });

    let stepIndex = 0;
    let dragging = false;
    let pointerId = null;

    const DONE_TOL = 0.992;

    function updateHeader() {
      stepPill.textContent = `Шаг ${stepIndex + 1} из ${steps.length}`;
      stepText.textContent = steps[stepIndex].title;
    }

    function clientToSvgPoint(clientX, clientY) {
      const pt = svg.createSVGPoint();
      pt.x = clientX;
      pt.y = clientY;
      const ctm = svg.getScreenCTM();
      if (!ctm) return { x: 0, y: 0 };
      const sp = pt.matrixTransform(ctm.inverse());
      return { x: sp.x, y: sp.y };
    }

    // “Насколько близко к линии нужно вести”
    function lineSnapRadius() {
      const sw = segState[stepIndex].strokeW;
      return sw * 6.0;
    }

    // Поиск ближайшей точки на пути: возвращает {len, dist2}
    const SNAP_SAMPLES = 110;
    const LOCAL_REFINE_ITERS = 10;

    function nearestOnPath(path, total, target) {
      let bestLen = 0;
      let bestDist2 = Infinity;

      for (let i = 0; i <= SNAP_SAMPLES; i++) {
        const t = i / SNAP_SAMPLES;
        const len = total * t;
        const pt = path.getPointAtLength(len);
        const dx = pt.x - target.x;
        const dy = pt.y - target.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestDist2) { bestDist2 = d2; bestLen = len; }
      }

      let step = total / SNAP_SAMPLES;
      for (let k = 0; k < LOCAL_REFINE_ITERS; k++) {
        step *= 0.5;
        const cands = [bestLen - step, bestLen, bestLen + step];
        for (const len0 of cands) {
          const len = Math.max(0, Math.min(total, len0));
          const pt = path.getPointAtLength(len);
          const dx = pt.x - target.x;
          const dy = pt.y - target.y;
          const d2 = dx*dx + dy*dy;
          if (d2 < bestDist2) { bestDist2 = d2; bestLen = len; }
        }
      }

      return { len: bestLen, d2: bestDist2 };
    }

    function setHandleTo(path, len) {
      const pt = path.getPointAtLength(len);
      handle.setAttribute('cx', pt.x);
      handle.setAttribute('cy', pt.y);
    }

    function setDraw(path, idx, len) {
      const total = segState[idx].total;
      const clamped = Math.max(0, Math.min(total, len));
      segState[idx].drawn = clamped;
      path.style.strokeDashoffset = String(total - clamped);
    }

    function teleportToCurrentStepStart() {
      stage.classList.add('teleport');
      setHandleTo(paths[stepIndex], 0);

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          stage.classList.remove('teleport');
        });
      });
    }

    function lightStarsForCurrentStepStart() {
      const p = paths[stepIndex];
      const startPt = p.getPointAtLength(0);
      starOn(nearestStarToPoint(startPt));
    }

    function lightStarsForStepEnd() {
      const p = paths[stepIndex];
      const endPt = p.getPointAtLength(segState[stepIndex].total);
      starOn(nearestStarToPoint(endPt));
    }

    function completeStep() {
      setDraw(paths[stepIndex], stepIndex, segState[stepIndex].total);
      lightStarsForStepEnd();

      if (stepIndex < paths.length - 1) {
        stepIndex += 1;
        updateHeader();
        teleportToCurrentStepStart();
        lightStarsForCurrentStepStart();
      } else {
        updateHeader();
      }
    }

    function applyMove(clientX, clientY) {
      const path = paths[stepIndex];
      const total = segState[stepIndex].total;
      const target = clientToSvgPoint(clientX, clientY);

      const { len: nearestLen, d2: nearestD2 } = nearestOnPath(path, total, target);

      // далеко от линии — не обновляем
      const snapR = lineSnapRadius();
      if (nearestD2 > snapR * snapR) return;

      // только вперёд
      const nextLen = Math.max(segState[stepIndex].drawn, nearestLen);

      setDraw(path, stepIndex, nextLen);
      setHandleTo(path, segState[stepIndex].drawn);

      if (segState[stepIndex].drawn / total >= DONE_TOL) {
        completeStep();
      }
    }

    function resetAll() {
      stepIndex = 0;
      for (let i = 0; i < paths.length; i++) setDraw(paths[i], i, 0);
      setHandleTo(paths[0], 0);
      starsReset();
      updateHeader();
      lightStarsForCurrentStepStart();
    }

    // Важный фикс: стартуем перетаскивание только с самого движка
    handle.addEventListener('pointerdown', (e) => {
      pointerId = e.pointerId;
      stage.setPointerCapture(pointerId);
      dragging = true;
      stage.classList.add('dragging');
      applyMove(e.clientX, e.clientY);
      e.preventDefault();
      e.stopPropagation();
    });

    stage.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      if (pointerId !== e.pointerId) return;
      applyMove(e.clientX, e.clientY);
    });

    function endDrag(e) {
      if (pointerId !== e.pointerId) return;
      dragging = false;
      pointerId = null;
      stage.classList.remove('dragging');
    }

    stage.addEventListener('pointerup', endDrag);
    stage.addEventListener('pointercancel', endDrag);

    btnReset.addEventListener('click', resetAll);

    resetAll();
  })();
  </script>
</body>
</html>
